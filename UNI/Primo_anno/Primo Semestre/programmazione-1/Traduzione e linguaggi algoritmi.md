
I linguaggi di programmazione sono classificati in tre
livelli:

• linguaggi macchina (1945)
• linguaggi assembly (1950)
• linguaggi di alto livello: dal 1950 in poi,

evoluzione verso:

• Astrazione
• Semplificazione
• Similarità con il ragionamento umano.


# **PARADIGMI DI PROGRAMMAZIONE**

**Programmazione funzionale:** Il flusso di
**esecuzione** è una serie di valutazioni di funzioni
matematiche.                                                                                    **<font color="#c00000">POCO USATA</font>

![image1728546329105.png](image1728546329105png.png)


**Programmazione logica:** Descrivere la
struttura logica del problema anziché il modo
per risolverlo (logica del primo ordine)                                     <font color="#c00000">POCO USATA</font>

![image1728546329262.png](image1728546329262png.png)

**Programmazione imperativa:** Sequenza di istruzioni
da “impartire” al calcolatore (ES: assegnazioni).

![image1728546329264.png](image1728546329264png.png)

**Programmazione strutturata:** Si basa sul teorema
di Bohm-Jacopini, quindi sui tre costrutti sequenza,
selezione, iterazione.

![image1728546329299.png](image1728546329299png.png)

**Programmazione procedurale:** Insieme di blocchi di
codice sorgente ben delimitati identificati da nome ed
eventuali argomenti (funzioni/procedure)

![image1728546329301.png](image1728546329301png.png)

**Programmazione modulare:** paradigma
basato sulla modularità, ovvero strutturare
un programma in moduli ben separati con
interfaccia ben definita.

![image1728546329312.png](image1728546329312png.png)

**Programmazione orientata agli oggetti:** Include aspetti di programmazione imperativa, strutturata, procedurale e modulare

![image1728546329314.png](image1728546329314png.png)






**Sintassi e semantica**

![image1728546329316.png](image1728546329316png.png)

**Un errore di semantica** In sostanza avviene quando il programma si avvia senza errori ma non da il risultato sperato.)

**Traduttori**

Un traduttore genera codice in linguaggio
macchina a partire da codice scritto in un
linguaggio di alto livello.

Grazie al concetto di traduzione:

• **evoluzione dei linguaggi** di programmazione
verso sistemi simbolici più espressivi.

• **molto più agevole** scrivere programmi

• **indipendenza dalla piattaforma:** il
programmatore scrive il programma senza
preoccuparsi della piattaforma sottostante.

Esistono **2** tipi di traduttori:

**Compilatori** e **Interpreti**

Un **compilatore** prende in input un codice sorgente e lo traduce in codice oggetto. (Crea un eseguibile [tipo C])

![image1728546329343.png](image1728546329343png.png)

--------------------------------------------------------------------------------

Un **interprete** prende in input un codice sorgente, come il
compilatore, ma:

![image1728546329356.png](image1728546329356png.png)





**Hanno dei pro e dei contro:**

![image1728546329354.png](image1728546329354png.png)

![image1728546329360.png](image1728546329360png.png)





# **ALGORITMI**
**Un algoritmo è una sequenza ordinata di passi che producono un ben determinato risultato in un tempo finito**
Una cosa fondamentale è che la semantica deve essere correttamente applicata all'algoritmo in modo che il computer possa interpretarlo nel modo corretto e senza ambiguità.

Un algoritmo ha varie caratteristiche: 
1. Non ci devono essere ambiguità.
2. Deve avere un numero finito di passi.
3. Ogni passo successivo è ben determinato.


Ogni passo deve terminare in un tempo finito e deve produrre un effetto osservabile, inoltre, a condizione di avere gli stessi input deve restituire sempre lo stesso effetto.

**Un algoritmo per essere interpretato dalla macchina ha bisogno di essere codificato in un apposito linguaggio di programmazione (diventa il programma)**

![[Pasted image 20241011104949.png|450]]

Solitamente quando si ha un problema da trasformare in un algoritmo si vanno a sviluppare dei sotto-problemi che rendano più facile la creazione dell'algoritmo.

**APPROCCIO TOP-DOWN** - un problema più grande si decompone in problemi più piccoli in modo da avere più dettagli.
**APPROCCIO BOTTOM-DOWN** - si sviluppano delle parti individuali del problema in maggiore dettaglio e poi vengono unite per arrivare a risolvere un problema più grande.

<font color="#c00000">Spesso si utilizza</font> un **APPROCCIO IBRIDO**.

Un algoritmo va descritto mediante:
**DIAGRAMMI DI FLUSSO**
![[Pasted image 20241011110058.png|300]]

**PSEUDO-CODIFICA**
![[Pasted image 20241011110236.png|300]]





# <font color="#000000">COME CREARE UN ALGORITMO</font>
ihfvo